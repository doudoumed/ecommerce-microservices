# شرح المرحلتين 4 و 5 (Phase 4 & 5 Explanation)

هذا المستند يقدم شرحاً تقنياً للمرحلتين الرابعة والخامسة من مشروع الخدمات المصغرة (Microservices)، موجه للمشرف التقني.

---

## المرحلة 4: الاتصال غير المتزامن (Asynchronous Communication)

### الهدف
تحويل النظام من الاعتماد الكلي على الاتصال المتزامن (Synchronous HTTP Calls) إلى نظام يعتمد على الأحداث (Event-Driven Architecture) لفك الارتباط بين الخدمات (Decoupling) وتحسين الأداء.

### التقنيات المستخدمة
- **RabbitMQ:** وسيط رسائل (Message Broker) لإدارة الطوابير والأحداث.
- **Pika:** مكتبة بايثون للتعامل مع RabbitMQ.

### تفاصيل التنفيذ
تم تصميم تدفق العمليات (Workflow) ليكون غير متزامن كالتالي:

1.  **إنشاء الطلب (Order Service):**
    - عند إنشاء طلب، يقوم `order-service` بنشر حدث `order.created` إلى RabbitMQ بدلاً من انتظار معالجة الدفع والشحن فوراً.
2.  **معالجة الدفع (Payment Service):**
    - يستمع `payment-service` لحدث `order.created`.
    - يقوم بمعالجة الدفع، ثم ينشر حدث `payment.completed`.
3.  **الشحن (Shipping Service):**
    - يستمع `shipping-service` لحدث `payment.completed`.
    - يقوم بإنشاء الشحنة، ثم ينشر حدث `shipment.created`.
4.  **الإشعارات (Notification Service):**
    - يستمع لجميع الأحداث (`order.created`, `payment.completed`, `shipment.created`) ويرسل إشعارات (محاكاة) للعميل.

### الفوائد المحققة
- **فك الارتباط (Loose Coupling):** الخدمات لا تحتاج لمعرفة وجود بعضها البعض، فقط تعرف "الأحداث".
- **الأداء (Performance):** استجابة أسرع للعميل حيث تتم العمليات الثقيلة في الخلفية.
- **الموثوقية (Reliability):** إذا توقفت خدمة الشحن مثلاً، تظل الرسائل في الطابور حتى تعود للعمل.

---

## المرحلة 5: المرونة وتحمل الأخطاء (Resilience & Fault Tolerance)

### الهدف
جعل النظام قادراً على الصمود والتعافي الذاتي عند حدوث أخطاء أو توقف في إحدى الخدمات، ومنع "تأثير الدومينو" (Cascading Failures).

### التقنيات والمفاهيم المطبقة

#### 1. قاطع الدائرة (Circuit Breaker)
- **المشكلة:** إذا توقفت خدمة الدفع، فإن خدمة الطلبات ستتوقف وتتراكم الطلبات الفاشلة.
- **الحل:** استخدام نمط Circuit Breaker (مكتبة `pybreaker`).
- **آلية العمل:**
    - عند فشل الاتصال بخدمة الدفع 5 مرات متتالية، تفتح الدائرة (Open State).
    - يتم تحويل الطلبات فوراً إلى مسار بديل (Fallback) دون انتظار المهلة (Timeout).
    - **المسار البديل:** يتم قبول الطلب مبدئياً وإرساله إلى طابور RabbitMQ ليتم معالجته لاحقاً عند عودة الخدمة.

#### 2. إعادة المحاولة (Retry Mechanism)
- **المشكلة:** فشل مؤقت في الشبكة (Transient Network Glitch).
- **الحل:** استخدام مكتبة `tenacity` لإعادة المحاولة.
- **التكوين:** إعادة المحاولة 3 مرات مع فاصل زمني يتضاعف تدريجياً (Exponential Backoff) لتجنب إغراق الخدمة المتعثرة.

#### 3. المهلة الزمنية (Timeouts)
- **المشكلة:** انتظار استجابة خدمة بطيئة قد يعلق النظام بأكمله.
- **الحل:** تحديد مهلة زمنية صارمة (مثلاً 3 ثوانٍ) لكل طلب خارجي.

#### 4. تحديد معدل الطلبات (Rate Limiting)
- **المشكلة:** حماية النظام من الاستخدام المفرط أو هجمات الحرمان من الخدمة (DoS).
- **الحل:** استخدام `Flask-Limiter` في بوابة التطبيقات (API Gateway).
- **السياسة:**
    - 100 طلب/15 دقيقة بشكل عام.
    - 50 طلب/دقيقة لإنشاء الطلبات (تم رفعها للاختبار).

### الفوائد المحققة
- **استمرارية العمل (High Availability):** النظام يظل يعمل حتى لو سقطت أجزاء منه.
- **تجربة مستخدم أفضل:** العميل يتلقى رداً فورياً (حتى لو كان "تم استلام طلبك وسيعالج لاحقاً") بدلاً من رسالة خطأ أو انتظار طويل.
