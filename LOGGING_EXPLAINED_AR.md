# شرح تنفيذ السجلات الهيكلية (Structured Logging) ومعرف الارتباط (Correlation ID)

لقد قمنا بتحديث جميع الخدمات المصغرة (Microservices) لتحسين "قابلية المراقبة" (Observability). إليك ما تم إنجازه خطوة بخطوة:

## 1. الهدف (Why?)
في السابق، كانت السجلات (Logs) عبارة عن نصوص عادية يصعب البحث فيها آلياً، ولم نكن نستطيع تتبع طلب مستخدم واحد عبر الخدمات المختلفة.
**الحل:** تحويل السجلات إلى تنسيق JSON وإضافة "معرف ارتباط" موحد لكل طلب.

## 2. الخطوات التي قمنا بها (What we did)

### الخطوة 1: إضافة مكتبة `python-json-logger`
قمنا بإضافة مكتبة `python-json-logger` إلى ملف `requirements.txt` لكل خدمة. هذه المكتبة مسؤولة عن تحويل السجلات من نص عادي إلى JSON.

### الخطوة 2: إعداد التنسيق (Configuration)
في ملف `app.py` لكل خدمة، قمنا بتغيير إعدادات الـ Logger ليكون كالتالي:
```python
formatter = jsonlogger.JsonFormatter('%(timestamp)s %(level)s %(name)s %(message)s')
```
هذا يضمن أن كل سطر في الـ Log يحتوي على الوقت، المستوى (INFO/ERROR)، والرسالة بتنسيق JSON.

### الخطوة 3: معرف الارتباط (Correlation ID) في API Gateway
الـ API Gateway هي نقطة الدخول. قمنا بتعديلها لتقوم بـ:
1.  فحص ما إذا كان الطلب يحتوي على `X-Correlation-ID`.
2.  إذا لم يوجد، تقوم بتوليد معرف جديد (UUID).
3.  إضافة هذا المعرف إلى ترويسات (Headers) الطلبات المرسلة للخدمات الأخرى.

### الخطوة 4: تمرير المعرف في الخدمات الأخرى
في كل خدمة (Order, Payment, Inventory, etc.)، قمنا بـ:
1.  استخراج `X-Correlation-ID` من الطلب القادم.
2.  تخزينه مؤقتاً (في `flask.g`).
3.  إضافته تلقائياً إلى أي رسالة Log (`extra={'correlation_id': ...}`).
4.  تمريره مرة أخرى عند الاتصال بخدمة أخرى (مثلاً Order Service تتصل بـ Payment Service).

## النتيجة النهائية
الآن، عندما يرسل المستخدم طلباً واحداً، يمكننا تتبعه عبر كل الخدمات باستخدام `correlation_id` واحد، وستكون السجلات جاهزة للإرسال إلى نظام مركزي مثل Elasticsearch مستقبلاً.
